.model tiny

codes SEGMENT 
    assume cs:codes
    org 100h        ; смещение префикса программного сегмента

main:

    jmp interrupt


    speed db 00011111b
    is_interrupt db 1 ; флаг, определяющий, было ли уже ранее перехвачено прерывание
    ; если было, возвращаем прежний обработчик
    cur_time db 0

my_handler proc near

    pushf ; сохраняем в стеке значения регистра FLAGS

    ; ah сервис
    ; 02H читать время из "постоянных" (CMOS) часов реального времени
    ; выход: CH = часы в коде BCD   (пример: CX = 1243H = 12:43)
        ;    CL = минуты в коде BCDpushf ; сохраняем в стеке значения регистраpushf ; сохраняем в стеке значения регистра FLAGS FLAGS
        ;    DH = секунды в коде BCD
    ; выход: CF = 1, если часы не работают
    mov ah, 02h 
    int 1ah ; 1ah - прерывание BIOS для работы с таймером

    cmp dh, cur_time ; если время (значение количества секунд в таймере компьютера) не изменилось, то ничего не делаем
    je no_change_speed

    mov cur_time, dh ; если время увеличилось, то заносим его в переменную и изменяем скорость автоповтора ввода
    dec speed ; с уменьшением cur_speed увеличивается скорость автоповтора ввода

set_speed:

    mov al, 0F3h ; команда F3h отвечает за параметры режима автоповтора нажатой клавиши ; '0' в начале числа можно и не писать, но тогда MASM будет воспринимать это как метку, потому что она начинается с буквы
    out 60h, al ; порт 60h предназначен для работы с клавиатурой и обычно принимает пары байтов последовательно: первый - код команды, второй - данные

    mov al, speed
    out 60h, al ; устанавливаем скорость автоповтора ввода

no_change_speed:

    popf

    db 0EAh

    old_handler dd  0 ; адрес старого обработчика прерываний (нужен для возвращения прежнего обработчика)


my_handler endp

interrupt: ; метка перехвата прерывания 

    mov ax, 3508h ; считали адрес обработчика прерывания таймера (35h - функция считывания адреса, 08 - таймер)
    int 21h ; в es адрес сегмента, в bx - смещение

    cmp es:is_interrupt, 1 
    je restore ; если обработчик уже был переопределен ранее, то возвращаем прежний обработчик

    mov word ptr old_handler, bx ; копируем в метку old_handler изначальный обработчик (смещение)
    mov word ptr old_handler + 2, es ; копируем в метку old_handler изначальный обработчик (сегмент)

    mov ax, 2508h
    mov dx, offset my_handler
    int 21h ; AH = 25h, AL = 1Ch - заменяем вектор 1Ch в таблице векторов прерываний на свой 
    ; (адрес берётся из DX или DS:DX в зависимости от расстояния до процедуры: near или far)

    mov dx, offset init_msg
    mov ah, 09h
    int 21h ; выводим сообщение об установлении резидента с новым обработчиком прерывания таймера

    mov ah, 27h ; вход: ah = 27h
    mov dx, offset interrupt ; dx = адрес последнего байта программы (считая от начала PSP) + 1
    int 27h ; оставляем программу резидентной 

restore:

    mov dx, offset exit_msg ; выводим сообщение о восстановлении прежнего обработчика прерывания таймера
    mov ah, 09h
    int 21h

    ; для установки характеристик режима автоповтора в порт 60h необходимо записать код команды 0F3h, затем байт, определяющий характеристики режима
    mov al, 0F3h ; команда F3h отвечает за параметры режима автоповтора нажатой клавиши ; '0' в начале числа можно и не писать, но тогда MASM будет воспринимать это как метку, потому что она начинается с буквы
    out 60h, al ; порт 60h предназначен для работы с клавиатурой и обычно принимает пары байтов последовательно: первый - код команды, второй - данные

    mov al, 0
    out 60h, al ; устанавливаем период автоповтора 30.0, задержку включения режима автоповтора 250 мс (восстанавливаем дефолтные значения)
    
    mov dx, word ptr es:old_handler                       
    mov ds, word ptr es:old_handler + 2
    mov ax, 2508h
    int 21h ; восстанавливаем старый обработчик прерывания таймера в таблице векторов прерываний

    mov ah, 49h ; Надо ли вычищать память из-под резидента? И работает ли это корректно?
    int 21h

    mov ax, 4c00h
    int 21h 

    init_msg db 'New interrupt handler installed.', '$'     ; объявляем здесь, а не вверху, чтобы эти строки не остались в резидентной части программы (они там не нужны)
    exit_msg db 'New interrupt handler uninstalled.', '$'

codes ENDS

END main
    